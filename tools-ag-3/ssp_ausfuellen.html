<!DOCTYPE html>
<html lang="de" class="h-full bg-slate-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSCAL SSP Editor + Workspace (Enhanced)</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
    <script>
        tailwind.config = { theme: { extend: { fontFamily: { sans: ['Inter', 'sans-serif'] } } } };
    </script>
    <style>
        .collapsible-content { transition: max-height 0.3s ease-out, opacity 0.3s ease-in-out; overflow: hidden; max-height: 0; opacity: 0; }
        .collapsible-content.open { max-height: 50000px; opacity: 1; } /* Increased max-height for complex controls */
        .chevron-icon { transition: transform 0.3s ease; }
        .chevron-icon.open { transform: rotate(90deg); }
        .param-placeholder { color: #60a5fa; font-family: monospace; font-weight: bold; background-color: rgba(30, 58, 138, 0.3); padding: 0 4px; border-radius: 4px; cursor: help; }
        .maturity-radio-label:hover { background-color: #334155; }
        /* Custom Scrollbar for better dark mode look */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body class="h-full p-4 md:p-8 font-sans text-slate-200">
    <div class="max-w-7xl mx-auto bg-slate-800 p-6 md:p-8 rounded-2xl shadow-lg">

        <header class="mb-6 pb-6 border-b border-slate-700">
            <h1 class="text-3xl font-bold text-white">OSCAL SSP Editor (Workspace)</h1>
            <p class="mt-2 text-slate-300">Laden Sie das SSP und alle lokal referenzierten Dateien (z.B. Risiko-Profile, Komponenten), um den Workspace zu initialisieren.</p>
        </header>

        <div class="mb-6 p-4 bg-slate-700/50 rounded-lg shadow-md border border-slate-600">
            <h2 class="text-lg font-semibold text-white mb-4">Workspace laden</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="ssp-uploader" class="block text-sm font-medium text-slate-300 mb-2">1. SSP JSON-Datei (Hauptdatei)</label>
                    <input id="ssp-uploader" type="file" accept=".json" class="block w-full text-sm text-slate-400
                        file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold
                        file:bg-blue-800 file:text-blue-200 hover:file:bg-blue-700 cursor-pointer">
                </div>
                <div>
                    <label for="associated-uploader" class="block text-sm font-medium text-slate-300 mb-2">2. Assoziierte Dateien (Profile, Komponenten...)</label>
                    <input id="associated-uploader" type="file" accept=".json" multiple class="block w-full text-sm text-slate-400
                        file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold
                        file:bg-slate-600 file:text-slate-200 hover:file:bg-slate-500 cursor-pointer">
                </div>
            </div>
            <div id="workspace-status" class="text-sm text-slate-400 mt-4">
                Bereit. Laden Sie Dateien, um zu beginnen. Änderungen starten die Verarbeitung automatisch neu.
            </div>
        </div>

        <div class="flex justify-end mb-6">
            <button id="save-button" class="bg-emerald-600 text-white font-medium py-2 px-6 rounded-lg shadow-md hover:bg-emerald-700 transition duration-150 disabled:bg-slate-600" disabled>
                SSP speichern
            </button>
        </div>

        <div id="ssp-editor" class="hidden space-y-4"></div>

        <div id="loading-indicator" class="hidden text-center py-8">
            <p id="loading-text" class="text-slate-400 animate-pulse">Verarbeite Workspace...</p>
        </div>

    </div>

    <script>
        // --- CONFIG ---
        // NEU: Fallback URL für den Katalog
        const GS_PLUS_CATALOG_URL = 'https://raw.githubusercontent.com/BSI-Bund/Stand-der-Technik-Bibliothek/refs/heads/main/Kompendien/Grundschutz%2B%2B-Kompendium/Grundschutz%2B%2B-Kompendium.json';

        // --- Workspace State ---
        const workspaceFiles = new Map();
        let sspData = null; 
        let sspFileName = 'edited-ssp.json'; 

        // --- Data State ---
        let catalogControlMap = new Map(); 
        let catalogParamMap = new Map();
        // NEU: Speichert Modifikationen (Alters, Set-Params) aus dem importierten Profil
        let profileModifications = { setParams: new Map(), alters: new Map() }; 
        let loadedRiskData = [];
        let componentDefinitions = new Map(); 
        let resourceLoadStatus = []; 

        // --- UI Elemente ---
        const sspUploader = document.getElementById('ssp-uploader');
        const associatedUploader = document.getElementById('associated-uploader');
        const saveButton = document.getElementById('save-button');
        const editorDiv = document.getElementById('ssp-editor');
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingText = document.getElementById('loading-text');
        const workspaceStatus = document.getElementById('workspace-status');

        // --- Event Listeners ---
        sspUploader.addEventListener('change', (e) => handleFileUpload(e, true));
        associatedUploader.addEventListener('change', (e) => handleFileUpload(e, false));
        saveButton.addEventListener('click', handleFileSave);

        // --- Helper Functions ---
        function generateUUID() {
            // Use crypto API for UUID generation
            return crypto.randomUUID();
        }

        function base64DecodeUnicode(str) {
            try {
                // Modern approach using TextDecoder
                const binaryString = atob(str);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder().decode(bytes);
            } catch (e) {
                console.error("Base64 Decoding Fehler:", e);
                return null;
            }
        }

        // --- ICON & STYLE CONFIG ---
        function getPropConfig(name) {
            const n = name.toLowerCase();
            const iconClass = "w-3 h-3 mr-1.5 flex-shrink-0";
            
            // Base Icons (SVG definitions remain the same)
             const icons = {
                shield: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></svg>`,
                zap: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>`,
                eye: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`,
                doc: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 011.414.586l5.414 5.414a1 1 0 01.586 1.414V19a2 2 0 01-2 2z"></path></svg>`,
                clock: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`,
                check: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`,
                alert: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>`,
                tag: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path></svg>`,
                cube: `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>`
            };

            // 1. SSP / Implementation Props
            if (n.includes('effective_on_c')) return { icon: icons.shield, color: 'text-red-200 bg-red-900/50 border-red-800', label: 'Confidentiality' };
            if (n.includes('effective_on_i')) return { icon: icons.shield, color: 'text-blue-200 bg-blue-900/50 border-blue-800', label: 'Integrity' };
            if (n.includes('effective_on_a')) return { icon: icons.shield, color: 'text-yellow-200 bg-yellow-900/50 border-yellow-800', label: 'Availability' };
            if (n.includes('phase')) return { icon: icons.clock, color: 'text-purple-200 bg-purple-900/50 border-purple-800', label: 'Phase' };
            if (n.includes('class') || n.includes('technical')) return { icon: icons.cube, color: 'text-slate-200 bg-slate-700 border-slate-600', label: 'Class' };

            // 2. Catalog / Statement Props (German Terms)
            if (n.includes('modalverb')) return { icon: icons.alert, color: 'text-fuchsia-200 bg-fuchsia-900/60 border-fuchsia-700', label: 'Modalverb' };
            if (n.includes('effort_level') || n.includes('aufwand')) return { icon: icons.zap, color: 'text-orange-200 bg-orange-900/60 border-orange-700', label: 'Aufwand' };
            if (n.includes('documentation') || n.includes('dokumentation')) return { icon: icons.doc, color: 'text-cyan-200 bg-cyan-900/60 border-cyan-700', label: 'Doku' };
            if (n.includes('ergebnis') || n.includes('result')) return { icon: icons.check, color: 'text-emerald-200 bg-emerald-900/60 border-emerald-700', label: 'Ergebnis' };
            if (n.includes('handlung')) return { icon: icons.tag, color: 'text-indigo-200 bg-indigo-900/60 border-indigo-700', label: 'Handlung' };
            if (n.includes('alt-identifier')) return { icon: icons.tag, color: 'text-gray-400 bg-gray-800 border-gray-700', label: 'ID' };

            // Default
            return { icon: icons.tag, color: 'text-slate-300 bg-slate-800 border-slate-600', label: name };
        }


        // --- Workspace Loading & Management ---

        async function handleFileUpload(event, isSsp) {
            const files = event.target.files;
            if (!files.length) return;

            loadingText.textContent = `Lade ${files.length} Datei(en)...`;
            loadingIndicator.classList.remove('hidden');
            
            if (isSsp) {
                // Clear previous state when loading a new SSP
                workspaceFiles.clear();
                sspData = null;
                catalogControlMap.clear();
                catalogParamMap.clear();
                profileModifications = { setParams: new Map(), alters: new Map() };
                sspFileName = files[0].name.replace('.json', '-edited.json') || 'edited-ssp.json';
            }

            const loadPromises = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const json = JSON.parse(e.target.result);
                            workspaceFiles.set(file.name, json);
                            if (isSsp && file.name === files[0].name) {
                                sspData = json;
                            }
                            resolve();
                        } catch (error) {
                            console.error(`Fehler beim Parsen von ${file.name}:`, error);
                            reject(`Datei ${file.name} ist kein gültiges JSON.`);
                        }
                    };
                    reader.onerror = () => reject(`Datei ${file.name} konnte nicht gelesen werden.`);
                    reader.readAsText(file, 'UTF-8');
                });
            });

            try {
                await Promise.all(loadPromises);
                updateWorkspaceStatus();
                await processWorkspace();
            } catch (error) {
                alert("Fehler beim Laden der Dateien: " + error);
                loadingIndicator.classList.add('hidden');
            }
        }

        function updateWorkspaceStatus() {
            let statusHtml = `<p>Dateien im Workspace (${workspaceFiles.size}):</p><ul class="list-disc list-inside ml-4 mt-1">`;
            const originalSspName = sspFileName.replace('-edited.json', '.json');
            workspaceFiles.forEach((content, name) => {
                if (name === originalSspName) {
                    statusHtml += `<li><span class="text-blue-300">${name}</span> (Haupt-SSP)</li>`;
                } else {
                    statusHtml += `<li>${name}</li>`;
                }
            });
            statusHtml += '</ul>';
            workspaceStatus.innerHTML = statusHtml;
        }

        // UPDATE: Added fallback catalog loading
        async function processWorkspace() {
            editorDiv.innerHTML = '';
            editorDiv.classList.add('hidden');
            saveButton.disabled = true;

            if (!sspData || !sspData['system-security-plan']) {
                loadingIndicator.classList.add('hidden');
                return;
            }

            loadingText.textContent = 'Verarbeite Workspace...';
            loadingIndicator.classList.remove('hidden');

            // Reset state for processing
            catalogControlMap.clear();
            catalogParamMap.clear();
            profileModifications = { setParams: new Map(), alters: new Map() };
            loadedRiskData = [];
            componentDefinitions.clear();
            resourceLoadStatus = [];

            const ssp = sspData['system-security-plan'];

            try {
                await processLinkedProfiles(ssp);
                await processComponentDefinitions(ssp);
                await processMainCatalog(ssp);

                // NEU: Fallback Catalog Loading, falls bisher kein Katalog geladen wurde
                if (catalogControlMap.size === 0) {
                    loadingText.textContent = 'Lade Fallback-Katalog (Grundschutz++)...';
                    await loadFallbackCatalog();
                }

                renderSSP(ssp);
                renderResourceStatus(); 
                editorDiv.classList.remove('hidden');
                saveButton.disabled = false;

            } catch (error) {
                console.error("Fehler bei der Workspace-Verarbeitung:", error);
                editorDiv.innerHTML = `<p class="text-red-400">Fehler bei der Verarbeitung: ${error.message}</p>`;
                editorDiv.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        async function loadReferencedResource(href) {
            if (!href) return null;
            const filename = href.split('/').pop(); 

            // Check if already loaded/attempted to avoid duplicate status entries in the same run
            const existingStatus = resourceLoadStatus.some(r => r.href === href);

            if (workspaceFiles.has(href)) {
                if (!existingStatus) resourceLoadStatus.push({ href, status: 'success', source: 'workspace' });
                return workspaceFiles.get(href);
            }
            if (workspaceFiles.has(filename)) {
                if (!existingStatus) resourceLoadStatus.push({ href, status: 'success', source: 'workspace (via filename)' });
                return workspaceFiles.get(filename);
            }

            if (href.startsWith('http://') || href.startsWith('https://')) {
                try {
                    const response = await fetch(href);
                    if (!response.ok) throw new Error(`Netzwerk-Status ${response.status}`);
                    const json = await response.json();
                    if (!existingStatus) resourceLoadStatus.push({ href, status: 'success', source: 'network' });
                    return json;
                } catch (error) {
                    if (!existingStatus) resourceLoadStatus.push({ href, status: 'error', source: 'network', error: error.message });
                    console.error(`Netzwerk-Fehler beim Laden von ${href}:`, error);
                    return null;
                }
            }
            
            if (!existingStatus) resourceLoadStatus.push({ href, status: 'missing', source: 'workspace' });
            return null;
        }

        // --- Data Processing Functions ---

        // NEU: Funktion zum Laden des Fallback-Katalogs
        async function loadFallbackCatalog() {
            try {
                // Wir nutzen loadReferencedResource, damit es im Status getrackt wird
                const catalogData = await loadReferencedResource(GS_PLUS_CATALOG_URL);
                if (catalogData && catalogData.catalog) {
                    processCatalogData(catalogData.catalog);
                }
            } catch (error) {
                console.error("Fehler beim Laden des Fallback-Katalogs:", error);
            }
        }

        async function processLinkedProfiles(ssp) {
            const links = ssp.metadata?.links || [];
            const profileLinks = links.filter(link => link.rel === 'profile' && link.href);
            const loadPromises = profileLinks.map(async (link) => {
                const profileData = await loadReferencedResource(link.href);
                if (profileData && profileData.profile) {
                    const profile = profileData.profile;
                    extractRiskData(profile, link.href);
                    extractEmbeddedCatalogs(profile);
                }
            });
            await Promise.all(loadPromises);
        }

        // UPDATE: Added logic to look for catalogs inside component definitions
        async function processComponentDefinitions(ssp) {
            const components = ssp['system-implementation']?.components || [];
            const definitionLinks = new Set();
            components.forEach(comp => {
                // Look for standard definition link or the custom link used by the generator
                const defLink = comp.links?.find(link => link.rel === 'component-definition' || link.rel === 'source-profile');
                if (defLink && defLink.href) definitionLinks.add(defLink.href);
            });

            const catalogLinks = new Set(); // Store catalog links found in definitions

            const loadPromises = Array.from(definitionLinks).map(async (href) => {
                const definitionData = await loadReferencedResource(href);
                 if (definitionData) {
                     if (definitionData['component-definition']) {
                        componentDefinitions.set(href, definitionData);
                        
                        // Extract catalog links from metadata if present
                        const links = definitionData['component-definition'].metadata?.links || [];
                        links.forEach(link => {
                            if ((link.rel === 'source-catalog' || link.rel === 'source') && link.href) {
                                catalogLinks.add(link.href);
                            }
                        });
                    } else if (definitionData['profile']) {
                        // Handle if the source is a profile (like some inputs for the generator)
                        componentDefinitions.set(href, definitionData); 
                    }
                }
            });
            await Promise.all(loadPromises);

            // Load catalogs found in component definitions
            const catalogLoadPromises = Array.from(catalogLinks).map(async (href) => {
                const catalogData = await loadReferencedResource(href);
                if (catalogData && catalogData.catalog) {
                    processCatalogData(catalogData.catalog);
                }
            });
            await Promise.all(catalogLoadPromises);
        }

        // UPDATE: Extrahiert Modifikationen (Alters, Set-Params) aus dem Hauptprofil
        async function processMainCatalog(ssp) {
            const profileHref = ssp['import-profile']?.href;
            if (!profileHref) return;
            const profileData = await loadReferencedResource(profileHref);
            
            if (profileData && profileData.profile) {
                const profile = profileData.profile;

                // 1. NEU: Extrahiere Modifikationen
                const modify = profile.modify;
                if (modify) {
                    if (modify['set-parameters']) {
                        modify['set-parameters'].forEach(p => {
                            if (p['param-id'] && p.values && p.values.length > 0) {
                                profileModifications.setParams.set(p['param-id'], p.values[0]);
                            }
                        });
                    }
                    if (modify['alters']) {
                        modify['alters'].forEach(a => {
                            if (a['control-id'] && a.adds) {
                                const existing = profileModifications.alters.get(a['control-id']) || [];
                                // Store the adds array for this control ID
                                profileModifications.alters.set(a['control-id'], [...existing, ...a.adds]);
                            }
                        });
                    }
                }

                // 2. Versuche Katalog aus den Importen zu laden
                if (profile.imports) {
                    for (const imp of profile.imports) {
                        const importedResource = await loadReferencedResource(imp.href);
                        // Prüfe, ob das Importierte ein Katalog ist.
                        if (importedResource && importedResource.catalog) {
                            processCatalogData(importedResource.catalog);
                        }
                    }
                }
            }
        }

        // --- Data Extraction ---

        function extractRiskData(profile, sourceHref) {
            const riskRefProp = profile.metadata?.props?.find(p => p.name === 'risk-analysis-details-ref');
            if (riskRefProp && riskRefProp.value) {
                const resourceId = riskRefProp.value.replace('#', '');
                const resource = profile["back-matter"]?.resources?.find(r => r.uuid === resourceId);
                if (resource && resource.attachments && resource.attachments.length > 0) {
                    const attachment = resource.attachments[0];
                    if (attachment.base64 && attachment.base64.value) {
                        try {
                            const decodedData = base64DecodeUnicode(attachment.base64.value);
                            if (!decodedData) throw new Error("Dekodierung fehlgeschlagen.");
                            const riskJson = JSON.parse(decodedData);
                            if (riskJson.risks) {
                                loadedRiskData.push({
                                    sourceHref: sourceHref,
                                    sourceTitle: profile.metadata.title || sourceHref,
                                    risks: riskJson.risks
                                });
                            }
                        } catch (e) {
                            console.error(`Fehler beim Parsen der Risiko-Daten aus ${sourceHref}:`, e);
                        }
                    }
                }
            }
        }

        function extractEmbeddedCatalogs(profile) {
            const resources = profile["back-matter"]?.resources || [];
            resources.forEach(resource => {
                const isCatalog = resource.rlinks?.some(rlink => rlink["media-type"] === "application/oscal.catalog+json");
                if (isCatalog && resource.attachments && resource.attachments.length > 0) {
                    const attachment = resource.attachments[0];
                    if (attachment.base64 && attachment.base64.value) {
                            try {
                            const decodedCatalog = base64DecodeUnicode(attachment.base64.value);
                            if (!decodedCatalog) throw new Error("Katalog-Dekodierung fehlgeschlagen.");
                            const catalogJson = JSON.parse(decodedCatalog);
                            if (catalogJson.catalog) processCatalogData(catalogJson.catalog);
                        } catch (e) {
                            console.error("Fehler beim Parsen des eingebetteten Katalogs:", e);
                        }
                    }
                }
            });
        }

        function processCatalogData(catalog) {
            function scanRecursively(items) {
                if (!items) return;
                items.forEach(item => {
                    if (item.id && (item.parts || item.class || item.title)) {
                        if (!catalogControlMap.has(item.id)) catalogControlMap.set(item.id, item);
                    }
                    if (item.params) {
                        item.params.forEach(p => {
                            if(p.id && !catalogParamMap.has(p.id)) catalogParamMap.set(p.id, p);
                        });
                    }
                    if (item.controls) scanRecursively(item.controls);
                    if (item.groups) scanRecursively(item.groups);
                });
            }
            if (catalog) {
                scanRecursively(catalog.groups);
                scanRecursively(catalog.controls);
            }
        }

        // --- Rendering Functions ---

        function renderSSP(ssp) {
            let resourceStatusHtml = createCollapsibleSection('resource-status', 'Ressourcen-Status', '<div id="resource-status-content-inner"></div>', true);
            let riskSectionHtml = '';
            
            if (loadedRiskData.length > 0) {
                riskSectionHtml = createCollapsibleSection('risk-analysis', 'Risikoanalyse (aus Profilen)', renderRiskAnalysis(ssp), true);
            }
            const implementationOpen = loadedRiskData.length === 0;

            editorDiv.innerHTML = `
                ${resourceStatusHtml}
                ${riskSectionHtml}
                ${createCollapsibleSection('metadata', 'Metadaten', renderMetadata(ssp.metadata))}
                ${createCollapsibleSection('system-characteristics', 'System-Charakteristika', renderSystemCharacteristics(ssp['system-characteristics']))}
                ${createCollapsibleSection('implementation', 'Komponenten-Implementierung', renderImplementation(ssp), implementationOpen)}
            `;
            attachCollapsibleListeners();
            attachEditorListeners();
            attachFilterListeners();
        }

         function renderResourceStatus() {
            const container = document.getElementById('resource-status-content-inner');
            if (!container) return;
            let html = '<div class="space-y-2">';
            
            // Filter out duplicates, keeping the last status
            const uniqueStatusMap = new Map();
            resourceLoadStatus.forEach(item => {
                // Prioritize success over error/missing if multiple statuses somehow exist
                if (!uniqueStatusMap.has(item.href) || item.status === 'success') {
                    uniqueStatusMap.set(item.href, item);
                }
            });

            // Convert map values to array and sort
            const sortedStatus = Array.from(uniqueStatusMap.values()).sort((a, b) => {
                const order = { error: 1, missing: 2, success: 3 };
                return (order[a.status] || 4) - (order[b.status] || 4);
            });

            if (sortedStatus.length === 0) {
                html += '<p class="text-slate-400">Keine externen Ressourcen referenziert.</p>';
            } else {

                sortedStatus.forEach(item => {
                    let statusClass = '', statusText = '';
                    switch (item.status) {
                        case 'success': statusClass = 'text-green-400'; statusText = `Geladen (aus ${item.source})`; break;
                        case 'error': statusClass = 'text-red-400'; statusText = `Fehler beim Laden (Netzwerk): ${item.error}`; break;
                        case 'missing': statusClass = 'text-orange-400'; statusText = 'FEHLT: Bitte über "Assoziierte Dateien" hochladen.'; break;
                    }
                    html += `<div class="flex justify-between items-start text-sm p-2 bg-slate-700 rounded-md">
                            <span class="text-slate-300 break-all mr-4">${item.href}</span>
                            <span class="${statusClass} font-medium flex-shrink-0">${statusText}</span>
                        </div>`;
                });
            }
            html += '</div>';
            container.innerHTML = html;
        }

        function createCollapsibleSection(id, title, contentHtml, isOpen = false) {
            const openClass = isOpen ? 'open' : '';
            return `<div class="border border-slate-700 rounded-lg overflow-hidden" data-section-id="${id}"> 
                    <button class="collapsible-header w-full flex justify-between items-center p-4 bg-slate-700 hover:bg-slate-600 focus:outline-none text-left">
                        <h2 class="text-xl font-semibold text-white">${title}</h2>
                        <svg class="chevron-icon ${openClass} w-5 h-5 text-slate-400 flex-shrink-0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" /></svg>
                    </button>
                    <div id="${id}-content" class="collapsible-content ${openClass} p-4 border-t border-slate-700 bg-slate-800">${contentHtml}</div>
                </div>`;
        }

        function attachCollapsibleListeners() {
            document.querySelectorAll('.collapsible-header').forEach(header => {
                // Clone and replace to ensure fresh listeners on re-render
                const newHeader = header.cloneNode(true);
                header.parentNode.replaceChild(newHeader, header);
                newHeader.addEventListener('click', () => {
                    const content = newHeader.nextElementSibling;
                    content.classList.toggle('open');
                    newHeader.querySelector('.chevron-icon').classList.toggle('open');
                });
            });
        }
        
        function attachEditorListeners() {
             document.querySelectorAll('.maturity-radio').forEach(radio => {
                radio.addEventListener('change', () => {
                    const ta = document.getElementById(radio.dataset.targetTextarea);
                    const desc = radio.dataset.description || '';
                    if (ta && desc !== "") { ta.value = desc; ta.focus(); }
                    else if (ta) { ta.focus(); }
                });
            });
        }

        function attachFilterListeners() {
            const filterContainers = document.querySelectorAll('.filter-container');
            
            filterContainers.forEach(container => {
                const compUuid = container.dataset.compUuid;
                
                container.querySelectorAll('.control-prop-filter').forEach(select => {
                     // Clone and replace to ensure fresh listeners on re-render
                    const newSelect = select.cloneNode(true);
                    select.parentNode.replaceChild(newSelect, select);

                    newSelect.addEventListener('change', () => {
                        const activeFilters = [];
                        // Re-query selects inside the container
                        container.querySelectorAll('.control-prop-filter').forEach(s => {
                            if (s.value !== 'all') {
                                activeFilters.push({
                                    type: s.dataset.filterType,
                                    value: s.value.toLowerCase()
                                });
                            }
                        });

                        const listContainer = document.querySelector(`.control-list-container[data-comp-uuid="${compUuid}"]`);
                        if (listContainer) {
                            const entries = listContainer.querySelectorAll('.control-entry');
                            entries.forEach(entry => {
                                const entryProps = (entry.dataset.filterProps || "").toLowerCase();
                                
                                const matchesAll = activeFilters.every(filter => {
                                    // Suchen nach |key:value|
                                    const searchString = `|${filter.type}:${filter.value}|`;
                                    return entryProps.includes(searchString);
                                });

                                entry.style.display = matchesAll ? 'block' : 'none';
                            });
                        }
                    });
                });
            });
        }

        // --- Risk Rendering ---
        function renderRiskAnalysis(ssp) {
            let html = '<div class="space-y-6">';
            loadedRiskData.forEach((riskProfile, sourceIndex) => {
                html += `<div class="p-4 border border-emerald-800 rounded-lg bg-slate-700/30 shadow-md">
                    <h3 class="text-lg font-bold text-white mb-2">${riskProfile.sourceTitle}</h3>
                    <p class="text-sm text-slate-400 mb-4">Quelle: <a href="${riskProfile.sourceHref}" target="_blank" class="text-blue-400 hover:underline break-all">${riskProfile.sourceHref}</a></p>
                    <div class="space-y-4">`;

                if (riskProfile.risks.length === 0) {
                    html += '<p class="text-slate-400">Keine Risiken in diesem Profil gefunden.</p>';
                } else {
                    riskProfile.risks.forEach((risk, riskIndex) => {
                        const riskId = `risk-${sourceIndex}-${riskIndex}`;
                        html += createCollapsibleSection(riskId, renderRiskHeader(risk), renderRiskDetails(risk, ssp), false);
                    });
                }
                html += `</div></div>`;
            });
            html += '</div>';
            return html;
        }

        function renderRiskHeader(risk) {
            const getBadgeClass = (value) => {
                switch (value) {
                    case 'low': return 'bg-green-800 text-green-200';
                    case 'medium': return 'bg-yellow-800 text-yellow-200';
                    case 'high': return 'bg-orange-800 text-orange-200';
                    case 'very-high': return 'bg-red-800 text-red-200';
                    default: return 'bg-slate-600 text-slate-200';
                }
            };
            return `<div class="flex flex-wrap items-center gap-4">
                    <span class="text-white font-semibold mr-4">${risk.title}</span>
                    <span class="text-xs font-medium px-2.5 py-0.5 rounded-full ${getBadgeClass(risk.likelihood)} capitalize">Likelihood: ${risk.likelihood}</span>
                    <span class="text-xs font-medium px-2.5 py-0.5 rounded-full ${getBadgeClass(risk.impact)} capitalize">Impact: ${risk.impact}</span>
                </div>`;
        }

        function renderRiskDetails(risk, ssp) {
            let html = `<div class="space-y-4 p-4 bg-slate-900 rounded-lg shadow-inner">
                <div><h4 class="text-sm font-medium text-slate-300">Beschreibung</h4><p class="text-sm text-slate-200 mt-1 whitespace-pre-wrap">${risk.description || 'N/A'}</p></div>
                <div><h4 class="text-sm font-medium text-slate-300">Bedrohung (Threat)</h4><p class="text-sm text-slate-200 mt-1 whitespace-pre-wrap">${risk.threat || 'N/A'}</p></div>
                <hr class="border-slate-700">
                <div><h4 class="text-lg font-semibold text-white mb-3">Mitigierende Controls (${risk.mitigatingControls.length})</h4>
                <div class="space-y-6">`;
            
            const sspComponents = ssp['system-implementation']?.components || [];
            const sspRequirements = ssp['control-implementation']?.['implemented-requirements'] || [];
            const sspSetParams = ssp['control-implementation']?.['set-parameters'] || [];
            const sspParamValuesMap = new Map();
            sspSetParams.forEach(sp => { if(sp.values && sp.values.length > 0) sspParamValuesMap.set(sp['param-id'], sp.values[0]); });

            risk.mitigatingControls.forEach(control => {
                const controlId = control.id;
                let foundImplementation = false;
                let controlsHtml = '';
                let sourceBadge = '';
                if (control.source === 'custom') sourceBadge = `<span class="ml-2 px-2 text-xs font-semibold rounded-full bg-green-800 text-green-100">Custom</span>`;
                else if (control.source === 'catalog') sourceBadge = `<span class="ml-2 px-2 text-xs font-semibold rounded-full bg-blue-800 text-blue-100">Katalog</span>`;

                html += `<div class="bg-slate-800 rounded p-2 border border-slate-700">
                         <div class="mb-2 text-sm text-white font-semibold">${controlId} ${sourceBadge}</div>`;

                if (sspComponents.length > 0) {
                    sspComponents.forEach(comp => {
                        const reqEntry = sspRequirements.find(r => r['control-id'] === controlId);
                        const byCompEntry = reqEntry?.['by-components']?.find(bc => bc['component-uuid'] === comp.uuid);
                        
                        if (byCompEntry) {
                            foundImplementation = true;
                            const defLink = comp.links?.find(link => link.rel === 'component-definition' || link.rel === 'source-profile');
                            const compDef = defLink ? componentDefinitions.get(defLink.href) : null;
                            let defControlMap = new Map();
                            
                            // Handle Component Definition or Profile source
                            if (compDef) {
                                 if (compDef['component-definition']?.components?.[0]) {
                                    const impls = compDef['component-definition'].components[0]['control-implementations'] || [];
                                    impls.forEach(i => (i['implemented-requirements'] || []).forEach(req => defControlMap.set(req['control-id'], req)));
                                 }
                                 // Profiles generally don't contain implementation details here.
                            }

                            controlsHtml += `<div class="ml-2 pl-4 border-l-2 border-emerald-600 mb-4">
                                <div class="text-xs text-emerald-400 font-bold mb-2 uppercase tracking-wide">Bereits implementiert in: ${comp.title}</div>
                                ${renderControlEntry(controlId, comp, byCompEntry, defControlMap.get(controlId), sspParamValuesMap)}
                            </div>`;
                        }
                    });

                    if (!foundImplementation) {
                        const defaultComp = sspComponents[0];
                        const defLink = defaultComp.links?.find(link => link.rel === 'component-definition' || link.rel === 'source-profile');
                        const compDef = defLink ? componentDefinitions.get(defLink.href) : null;
                        let implReq = null;
                         if (compDef && compDef['component-definition']?.components?.[0]) {
                            const impls = compDef['component-definition'].components[0]['control-implementations'] || [];
                             impls.forEach(i => (i['implemented-requirements'] || []).forEach(req => {
                                 if(req['control-id'] === controlId) implReq = req;
                             }));
                        }

                        controlsHtml += `<div class="ml-2 pl-4 border-l-2 border-slate-500 mb-2">
                            <div class="text-xs text-slate-400 font-bold mb-2 uppercase tracking-wide">Neu anlegen für: ${defaultComp.title}</div>
                            ${renderControlEntry(controlId, defaultComp, null, implReq, sspParamValuesMap)}
                        </div>`;
                    }
                } else {
                    controlsHtml += `<p class="text-red-400 text-sm">Keine System-Komponenten definiert. Bitte erst Komponenten im SSP anlegen/laden.</p>`;
                }

                html += `${controlsHtml}</div>`;
            });
            html += `</div></div></div>`;
            return html;
        }

        // --- Standard SSP Rendering ---
        function renderMetadata(metadata) {
            return `<div class="space-y-3">
                <div><label class="block text-sm font-medium text-slate-300">Titel</label>
                <input type="text" id="metadata-title" class="mt-1 block w-full rounded-md border-slate-600 bg-slate-700 text-white" value="${(metadata.title || '').replace(/"/g, '&quot;')}"></div>
                <div><span class="block text-sm font-medium text-slate-300">Letzte Änderung (wird beim Speichern aktualisiert)</span>
                <p class="text-sm text-slate-300">${metadata['last-modified'] || 'N/A'}</p></div>
            </div>`;
        }

        function renderSystemCharacteristics(chars) {
            return `<div class="space-y-3">
                <div><label class="block text-sm font-medium text-slate-300">System-Name</label>
                <input type="text" id="system-name" class="mt-1 block w-full rounded-md border-slate-600 bg-slate-700 text-white" value="${(chars['system-name'] || '').replace(/"/g, '&quot;')}"></div>
                <div><label class="block text-sm font-medium text-slate-300">Beschreibung</label>
                <textarea id="system-description" rows="4" class="mt-1 block w-full rounded-md border-slate-600 bg-slate-700 text-white">${chars.description || ''}</textarea></div>
            </div>`;
        }

        // --- Implementation Rendering ---
        function renderImplementation(ssp) {
            const sspComponents = ssp['system-implementation']?.components || [];
            const sspRequirements = ssp['control-implementation']?.['implemented-requirements'] || [];
            
            const sspSetParams = ssp['control-implementation']?.['set-parameters'] || [];
            const sspParamValuesMap = new Map();
            sspSetParams.forEach(sp => {
                if(sp.values && sp.values.length > 0) sspParamValuesMap.set(sp['param-id'], sp.values[0]);
            });

            if (!sspComponents.length) return '<p class="text-slate-400">Keine Komponenten.</p>';

            let html = '<div class="space-y-4">';
            sspComponents.forEach((sspComp, index) => {
                const compUuid = sspComp.uuid;
                // Find definition link (handle both standard and generator specific rels)
                const defLink = sspComp.links?.find(link => link.rel === 'component-definition' || link.rel === 'source-profile');
                const compDef = defLink ? componentDefinitions.get(defLink.href) : null;

                const sspControlMap = new Map();
                sspRequirements.forEach(r => {
                    const entry = r['by-components']?.find(bc => bc['component-uuid'] === compUuid);
                    if (entry) sspControlMap.set(r['control-id'], entry);
                });

                const defControlMap = new Map();
                // Handle Component Definitions
                if (compDef && compDef['component-definition'] && compDef['component-definition']?.components?.[0]) {
                    const impls = compDef['component-definition'].components[0]['control-implementations'] || [];
                    impls.forEach(i => (i['implemented-requirements'] || []).forEach(req => defControlMap.set(req['control-id'], req)));
                } 
                // Handle if the source is a Profile
                else if (compDef && compDef['profile'] && compDef['profile'].imports) {
                    // Simple extraction of included controls in a profile
                     compDef['profile'].imports.forEach(imp => {
                         (imp["include-controls"]||[]).forEach(inc => {
                             if(inc["with-ids"]) inc["with-ids"].forEach(id => {
                                 if (!defControlMap.has(id)) defControlMap.set(id, { "control-id": id, "description": "Imported via Profile" });
                             });
                         });
                     });
                }

                // Combine keys from SSP implementation, definition (if found).
                const allKeys = new Set([...sspControlMap.keys(), ...defControlMap.keys()]);
                
                // Ensure controls mentioned only in Profile modifications (alters) are also included
                profileModifications.alters.forEach((_, cid) => allKeys.add(cid));
                
                const sortedKeys = Array.from(allKeys).sort();
                
                // --- Gather Filter Data (SSP + Catalog) ---
                const filterOptions = {}; 
                const addOpt = (type, val) => {
                    if(!type || !val) return;
                    if(!filterOptions[type]) filterOptions[type] = new Set();
                    filterOptions[type].add(val);
                };

                sortedKeys.forEach(cid => {
                    const implReq = defControlMap.get(cid);
                    const catCtrl = catalogControlMap.get(cid);

                    // 1. SSP Props
                    if (implReq && implReq.props) {
                        implReq.props.forEach(p => addOpt(p.name, p.value));
                    }
                    // 2. Class
                    if(catCtrl && catCtrl.class) addOpt('class', catCtrl.class);

                    // 3. Catalog Control Props (e.g. effort_level)
                    if (catCtrl && catCtrl.props) {
                        catCtrl.props.forEach(p => addOpt(p.name, p.value));
                    }

                    // 4. Statement Props (e.g. modalverb)
                    const stmt = catCtrl?.parts?.find(p => p.name === 'statement');
                    if (stmt && stmt.props) {
                        stmt.props.forEach(p => addOpt(p.name, p.value));
                    }
                });
                
                // --- Generate Filter HTML ---
                let filterBarHtml = '';
                
                // Config Map for Filter Labels
                const configMap = {
                    'class': 'Klasse / Class',
                    'phase': 'Phase',
                    'modalverb': 'Modalverb (Muss/Soll)',
                    'effort_level': 'Aufwand',
                    'documentation': 'Doku-Pflicht',
                    'effective_on_c': 'Confidentiality',
                    'effective_on_i': 'Integrity',
                    'effective_on_a': 'Availability'
                };

                // Sortierte Keys
                const keys = Object.keys(filterOptions).sort();
                
                keys.forEach(key => {
                    if (key !== 'alt-identifier' && (configMap[key] || key.startsWith('effective') || key.includes('phase'))) {
                        
                        const label = configMap[key] || getPropConfig(key).label;
                        const options = Array.from(filterOptions[key]).sort();
                        
                        let optsHtml = `<option value="all">Alle</option>`;
                        options.forEach(opt => {
                             optsHtml += `<option value="${opt.toLowerCase()}">${opt}</option>`;
                        });

                        filterBarHtml += `
                            <div class="flex flex-col min-w-[120px]">
                                <label class="text-[10px] text-slate-400 mb-1 font-bold uppercase tracking-wider">${label}</label>
                                <select data-filter-type="${key}" class="control-prop-filter rounded border-slate-600 bg-slate-800 text-white text-xs py-1.5 pl-2 pr-8 focus:ring-blue-500 focus:border-blue-500 shadow-sm">
                                    ${optsHtml}
                                </select>
                            </div>
                        `;
                    }
                });

                
                let compControlsHtml = `<div class="space-y-4 control-list-container" data-comp-uuid="${compUuid}">`;
                if (sortedKeys.length > 0) {
                    sortedKeys.forEach(cid => {
                        compControlsHtml += renderControlEntry(
                            cid, sspComp, sspControlMap.get(cid), defControlMap.get(cid), sspParamValuesMap
                        );
                    });
                } else {
                     compControlsHtml += '<p class="text-slate-400 text-sm">Keine Controls gefunden oder Katalog nicht geladen.</p>';
                }
                compControlsHtml += '</div>';

                const isOpen = index === 0; 
                const openClass = isOpen ? 'open' : '';
                
                html += `
                    <div class="border border-slate-700 rounded-lg overflow-hidden bg-slate-800 shadow-sm">
                        <button class="collapsible-header w-full flex justify-between items-center p-4 hover:bg-slate-700 text-left">
                            <h3 class="text-lg font-bold text-white">${sspComp.title}</h3>
                            <svg class="chevron-icon ${openClass} w-5 h-5 text-slate-400 flex-shrink-0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="m8.25 4.5 7.5 7.5-7.5 7.5" /></svg>
                        </button>
                        <div class="collapsible-content ${openClass} p-4 border-t border-slate-700 bg-slate-800">
                            
                            ${filterBarHtml ? `
                            <div class="mb-6 p-4 bg-slate-700/30 rounded-lg border border-slate-600/50 filter-container shadow-inner" data-comp-uuid="${sspComp.uuid}">
                                <div class="text-xs text-blue-300 mb-3 font-bold flex items-center tracking-wide">
                                    <svg class="w-4 h-4 mr-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path></svg>
                                    FILTER (UND-Verknüpfung)
                                </div>
                                <div class="flex flex-wrap gap-4">
                                    ${filterBarHtml}
                                </div>
                            </div>` : ''}

                            ${compControlsHtml}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            return html;
        }

        // --- Control Entry Rendering (UPDATED WITH MODIFICATIONS) ---
        function renderControlEntry(controlId, sspComponent, byCompEntry, implementedReq, sspParamValuesMap) {
            const compUuid = sspComponent.uuid;
            const uniqueDomId = `${controlId.replace(/[^a-zA-Z0-9]/g, '-')}-${compUuid}`;
            
            // Status & Values from SSP
            const currentState = byCompEntry?.['implementation-status']?.state || '';
            const currentDesc = byCompEntry?.description || '';
            const currentName = byCompEntry?.props?.find(p => p.name === 'implementing-user')?.value || '';
            const currentDate = byCompEntry?.props?.find(p => p.name === 'implementation-date')?.value || '';

            // Catalog Data
            const catCtrl = catalogControlMap.get(controlId);
            const title = catCtrl?.title || '(Titel nicht im Katalog gefunden)'; 
            const catClass = catCtrl?.class || 'unknown';
            const displayClass = catClass !== 'unknown' ? ` <span class="text-xs font-mono text-slate-500 border border-slate-700 px-1 rounded">class: ${catClass}</span>` : '';
            
            let filterDataString = `|class:${catClass}|`; 

            // --- 1. Catalog Control Props (e.g., Effort Level) ---
            const catProps = catCtrl?.props || [];
            let catPropsHtml = '';
            if (catProps.length > 0) {
                catPropsHtml = '<div class="flex flex-wrap gap-2 mt-2 mb-3">';
                catProps.forEach(p => {
                    filterDataString += `${p.name.toLowerCase()}:${p.value.toLowerCase()}|`;
                    const conf = getPropConfig(p.name);
                    catPropsHtml += `<span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] uppercase tracking-wider font-semibold border ${conf.color}" title="${p.name}: ${p.value}">
                        ${conf.icon}
                        <span class="mr-1 opacity-70">${conf.label}:</span> ${p.value}
                    </span>`;
                });
                catPropsHtml += '</div>';
            }

            // --- Component Implementation Props (SSP) ---
            const defProps = implementedReq?.props || [];
            let propsHtml = '';
            
            if (defProps.length > 0) {
                propsHtml = '<div class="flex flex-wrap gap-2 mt-2 border-t border-slate-700/50 pt-2">';
                defProps.forEach(p => {
                    filterDataString += `${p.name.toLowerCase()}:${p.value.toLowerCase()}|`;
                    const conf = getPropConfig(p.name); 
                    propsHtml += `<span class="inline-flex items-center px-2 py-1 rounded text-xs font-medium border ${conf.color}" title="${p.name}">
                        ${conf.icon}
                        ${p.value}
                    </span>`;
                });
                propsHtml += '</div>';
            }

            // --- Params Logic Initialization ---
            let paramsHtml = '';
            let referencedParams = new Set();
            if (catCtrl && catCtrl.params) catCtrl.params.forEach(p => referencedParams.add(p.id));

            // --- Prose & Statement Props Logic ---
            const statementPart = catCtrl?.parts?.find(p => p.name === 'statement');
            let proseText = statementPart?.prose || '';

            // --- NEU: Apply 'Alters' modifications (before, starting, ending, after) ---
            const alters = profileModifications.alters.get(controlId) || [];

            // Helper function to extract prose from parts
            const extractProse = (parts) => parts?.map(p => p.prose).filter(Boolean).join('\n') || '';

            let beforeHtml = '', startingHtml = '', endingHtml = '', afterHtml = '';

            // Define styles for the modifications (Violet)
            const modStyle = "text-sm text-purple-300 bg-purple-900/30 p-3 rounded-lg border border-purple-700 my-2 whitespace-pre-wrap shadow-md";
            const modHeaderStyle = "block text-xs font-bold uppercase text-purple-400 mb-2 tracking-wide";

            alters.forEach(add => {
                const modText = extractProse(add.parts);
                if (!modText) return;

                const html = `<div class="${modStyle}">
                                <span class="${modHeaderStyle}">[MODIFIKATION: ${add.position}]</span>
                                ${modText}
                              </div>`;
                switch (add.position) {
                    case 'before': beforeHtml += html; break;
                    // For starting/ending, wrap in div for margin inside the main prose box
                    case 'starting': startingHtml += `<div class="mb-3">${html}</div>`; break; 
                    case 'ending': endingHtml += `<div class="mt-3">${html}</div>`; break;
                    case 'after': afterHtml += html; break;
                }
            });
            
            // Extract Statement Props (e.g. modalverb, documentation)
            const stmtProps = statementPart?.props || [];
            let stmtPropsHtml = '';
            if (stmtProps.length > 0) {
                stmtPropsHtml = '<div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-3 pt-3 border-t border-slate-600/50">';
                stmtProps.forEach(p => {
                    filterDataString += `${p.name.toLowerCase()}:${p.value.toLowerCase()}|`;
                    const conf = getPropConfig(p.name);
                    stmtPropsHtml += `<div class="flex items-center text-xs p-1.5 rounded bg-slate-900/30 border border-slate-700/50">
                        <div class="${conf.color.split(' ')[0]} mr-2">${conf.icon}</div>
                        <div>
                            <span class="block text-[10px] uppercase text-slate-500 font-bold leading-tight">${conf.label}</span>
                            <span class="text-slate-300 font-medium">${p.value}</span>
                        </div>
                    </div>`;
                });
                stmtPropsHtml += '</div>';
            }

            // Param replacement in Prose
            const paramRegex = /{{\s*insert:\s*param,\s*([a-zA-Z0-9._-]+)\s*}}/g;
            let match;
            // Ensure we capture params referenced in the original prose
            if (proseText) {
                while ((match = paramRegex.exec(proseText)) !== null) referencedParams.add(match[1]);
            }

            // Replace placeholders in the original prose
            if (proseText) {
                proseText = proseText.replace(paramRegex, (match, pId) => {
                    const pDef = catalogParamMap.get(pId);
                    const label = pDef?.label || pId;
                    return `<span class="param-placeholder" title="Parameter ID: ${pId}">[${label}]</span>`;
                });
            }
            
            // --- NEU: Render Params Inputs (Prioritize Profile Mods) ---
            // Ensure we also show params defined ONLY in the modifications, even if not in the catalog prose, if they relate to this control
            profileModifications.setParams.forEach((val, pid) => {
                // Heuristic: BSI params often start with the control ID.
                if (pid.startsWith(controlId)) {
                    referencedParams.add(pid);
                }
            });


            if (referencedParams.size > 0) {
                paramsHtml = `<div class="mt-4 pt-4 border-t border-slate-600 bg-slate-800/50 p-3 rounded-md border border-blue-900/30">
                    <h5 class="text-xs font-bold text-blue-300 mb-2 uppercase tracking-wide">Parameter</h5>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">`;
                
                // Sort parameters for consistent display
                const sortedParams = Array.from(referencedParams).sort();

                sortedParams.forEach(paramId => {
                    const paramDef = catalogParamMap.get(paramId);
                    const label = paramDef?.label || paramId;
                    
                    // Determine the value: 
                    // 1. Check SSP (if already edited/saved)
                    // 2. Check Profile Modification (the blueprint value)
                    const sspVal = sspParamValuesMap.get(paramId);
                    const profileVal = profileModifications.setParams.get(paramId);
                    
                    // Prioritize SSP value if it exists (is not undefined), otherwise use the profile value.
                    const savedVal = sspVal !== undefined ? sspVal : (profileVal || '');

                    // Flag if the value comes from the profile modification AND the SSP didn't have its own value
                    const isFromProfile = sspVal === undefined && profileVal !== undefined;
                    // Highlight with purple if it's from the blueprint profile
                    const highlightClass = isFromProfile ? 'border-purple-500 ring-1 ring-purple-500' : 'border-slate-600';
                    const tooltip = isFromProfile ? 'Initialwert aus Blaupausen-Profil übernommen.' : '';
                    
                    paramsHtml += `<div>
                            <label class="block text-[10px] text-slate-400 mb-1 font-mono">${label}</label>
                            <input type="text" data-param-id="${paramId}" title="${tooltip}"
                                class="param-input block w-full rounded bg-slate-700 text-white text-xs py-1.5 px-2 focus:ring-1 focus:ring-blue-500 ${highlightClass}"
                                value="${savedVal.replace(/"/g, '&quot;')}" placeholder="${paramId}...">
                        </div>`;
                });
                paramsHtml += `</div></div>`;
            }

            const guidanceText = catCtrl?.parts?.find(p => p.name === 'guidance')?.prose || '';
            const compDesc = implementedReq?.description || '';
            const statements = implementedReq?.statements || [];
            
            return `
                <div class="control-entry p-4 border border-slate-600 rounded-lg bg-slate-700 shadow-sm mb-4" 
                     data-control-id="${controlId}" data-comp-uuid="${compUuid}" data-control-class="${catClass}"
                     data-filter-props="${filterDataString}">
                    
                    ${beforeHtml} 

                    <div class="mb-2">
                        <div class="flex justify-between items-start">
                            <h4 class="text-lg font-bold text-white leading-tight">
                                <span class="text-blue-400 mr-1">${controlId}</span> ${title}
                            </h4>
                            ${displayClass}
                        </div>
                        ${catPropsHtml}
                        ${propsHtml} 
                    </div>

                    <div class="mt-3 text-sm group relative">
                        ${(!catCtrl) ? '<p class="text-orange-400 italic mb-2">Control-Details nicht im Workspace/Katalog gefunden.</p>' : ''}
                        
                        ${proseText || startingHtml || endingHtml ? `
                        <div class="rounded-md bg-slate-800 border border-slate-600 overflow-hidden">
                            <div class="p-4 text-slate-100 font-medium leading-relaxed bg-gradient-to-r from-slate-800 to-slate-800/50">
                                
                                ${startingHtml} 

                                ${proseText}
                                
                                ${endingHtml} 

                            </div>
                            ${stmtPropsHtml ? `<div class="bg-slate-900/50 px-4 pb-4">${stmtPropsHtml}</div>` : ''}
                        </div>
                        ` : ''}
                        
                        ${guidanceText ? `
                        <div class="mt-2 pl-3 border-l-2 border-slate-600 text-slate-400 text-xs italic">
                            <span class="font-bold not-italic text-slate-500 text-[10px] uppercase block mb-1">Guidance</span>
                            ${guidanceText}
                        </div>` : ''}
                    </div>

                    ${afterHtml}

                    ${paramsHtml}

                    ${compDesc ? `<div class="mt-4 pt-3 border-t border-slate-600 text-sm">
                        <span class="text-[10px] text-blue-300 uppercase font-bold block mb-1">Aktuelle Implementierungs-Beschreibung (aus Definition)</span>
                        <div class="p-3 bg-slate-900 border border-blue-900/50 text-blue-100 rounded text-xs whitespace-pre-wrap">${compDesc}</div>
                    </div>` : ''}

                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mt-4 pt-4 border-t border-slate-600 bg-slate-700/50 -mx-4 px-4 pb-2">
                        <div class="md:col-span-1">
                            <label class="block text-xs text-slate-300 mb-1 font-semibold">Status</label>
                            <select id="state-${uniqueDomId}" class="w-full rounded bg-slate-800 border-slate-600 text-white text-sm py-1.5">
                                <option value="" ${currentState===''?'selected':''}>-- Offen --</option>
                                <option value="implemented" ${currentState==='implemented'?'selected':''}>Umgesetzt</option>
                                <option value="partial" ${currentState==='partial'?'selected':''}>Teilweise</option>
                                <option value="planned" ${currentState==='planned'?'selected':''}>Geplant</option>
                                <option value="alternative" ${currentState==='alternative'?'selected':''}>Alternative</option>
                                <option value="not-applicable" ${currentState==='not-applicable'?'selected':''}>Nicht zutreffend</option>
                            </select>
                        </div>
                        <div class="md:col-span-2">
                            <label class="block text-xs text-slate-300 mb-1 font-semibold">Bearbeiter</label>
                            <input type="text" id="name-${uniqueDomId}" class="w-full rounded bg-slate-800 border-slate-600 text-white text-sm py-1.5" value="${currentName}">
                        </div>
                        <div class="md:col-span-1">
                            <label class="block text-xs text-slate-300 mb-1 font-semibold">Datum</label>
                            <input type="date" id="date-${uniqueDomId}" class="w-full rounded bg-slate-800 border-slate-600 text-white text-sm py-1.5" value="${currentDate}">
                        </div>
                        <div class="md:col-span-4">
                            <label class="block text-xs text-slate-300 mb-1 font-semibold">Kommentar / Umsetzung</label>
                            ${renderStatementsRadio(statements, uniqueDomId, currentDesc)}
                            <textarea id="desc-${uniqueDomId}" rows="3" class="w-full rounded bg-slate-800 border-slate-600 text-white text-sm mt-2 focus:ring-blue-500 focus:border-blue-500 placeholder-slate-500" placeholder="Beschreiben Sie die Umsetzung...">${currentDesc}</textarea>
                        </div>
                    </div>
                </div>
            `;
        }

         function renderStatementsRadio(statements, uniqueDomId, currentDesc) {
            if (!statements || statements.length === 0) return '';
            
            let manualChecked = true;
            let radiosHtml = statements.map((stmt, idx) => {
                const props = stmt.props || [];
                const stmtText = props.find(p => p.name === 'statement')?.value || '';
                const guidance = props.find(p => p.name === 'guidance')?.value || '';
                const assessment = props.find(p => p.name === 'assessment-method')?.value || '';

                const isChecked = (currentDesc.trim() === stmtText.trim() && stmtText !== '');
                if (isChecked) manualChecked = false;
                
                return `
                <div class="flex items-start mt-4 maturity-radio-label rounded-md p-2 bg-slate-800/50 border border-slate-700">
                    <input type="radio" id="r-${uniqueDomId}-${idx}" name="mat-${uniqueDomId}" 
                        class="maturity-radio mt-1 bg-slate-700 border-slate-500 text-blue-600 focus:ring-blue-500"
                        data-target-textarea="desc-${uniqueDomId}" data-description="${stmtText.replace(/"/g, '&quot;')}" ${isChecked ? 'checked':''}>
                    
                    <label for="r-${uniqueDomId}-${idx}" class="ml-3 w-full cursor-pointer">
                        <div class="text-sm font-bold text-white mb-1">${stmt.description || 'Level '+(idx+1)}</div>
                        
                        ${stmtText ? `<div class="text-sm text-slate-300 mb-2">${stmtText}</div>` : ''}
                        
                        ${guidance ? `<div class="text-xs text-slate-400 italic mb-1 pl-2 border-l-2 border-slate-600"><span class="font-semibold not-italic text-slate-500">Guidance:</span> ${guidance}</div>` : ''}
                        
                        ${assessment ? `<div class="text-xs text-emerald-400/80 mt-1 pl-2 border-l-2 border-emerald-900/50"><span class="font-semibold text-emerald-500/80">Prüfung:</span> ${assessment}</div>` : ''}
                    </label>
                </div>`;
            }).join('');

            return `
                <div class="mb-2 space-y-2">
                    <div class="flex items-center maturity-radio-label rounded-md p-2 bg-slate-800/50 border border-slate-700">
                        <input type="radio" id="r-man-${uniqueDomId}" name="mat-${uniqueDomId}" 
                            class="maturity-radio bg-slate-700 border-slate-500 text-blue-600 focus:ring-blue-500"
                            data-target-textarea="desc-${uniqueDomId}" data-description="" ${manualChecked?'checked':''}>
                        <label for="r-man-${uniqueDomId}" class="ml-3 text-sm text-white font-medium cursor-pointer">Manuelle Eingabe / Abweichung</label>
                    </div>
                    ${radiosHtml}
                </div>
            `;
        }


        // --- Save Logic ---
        function handleFileSave() {
            if (!sspData) return;

            try {
                const ssp = sspData['system-security-plan'];
                
                // 1. Metadaten etc.
                ssp.metadata.title = document.getElementById('metadata-title').value;
                ssp['system-characteristics']['system-name'] = document.getElementById('system-name').value;
                ssp['system-characteristics'].description = document.getElementById('system-description').value;
                ssp.metadata["last-modified"] = new Date().toISOString();

                if (!ssp['control-implementation']) ssp['control-implementation'] = {};
                
                // Parameter speichern
                const paramInputs = document.querySelectorAll('.param-input');
                const setParameters = [];
                // Use a map to ensure unique param-ids (as inputs might appear multiple times if control is implemented by multiple components)
                const paramMap = new Map();

                paramInputs.forEach(input => {
                    const val = input.value.trim();
                    const paramId = input.dataset.paramId;
                    // Save non-empty values to the SSP.
                    if (val && paramId) {
                        paramMap.set(paramId, val);
                    }
                });

                paramMap.forEach((value, paramId) => {
                    setParameters.push({ "param-id": paramId, "values": [ value ] });
                });

                // Only set if not empty, otherwise delete the key if it exists
                if (setParameters.length > 0) {
                    ssp['control-implementation']['set-parameters'] = setParameters;
                } else {
                    delete ssp['control-implementation']['set-parameters'];
                }
                

                // 2. Requirements
                if (!Array.isArray(ssp['control-implementation']['implemented-requirements'])) {
                    ssp['control-implementation']['implemented-requirements'] = [];
                }
                let requirements = ssp['control-implementation']['implemented-requirements'];
                const controlEntries = document.querySelectorAll('.control-entry');

                controlEntries.forEach(entry => {
                    const controlId = entry.dataset.controlId;
                    const compUuid = entry.dataset.compUuid;
                    const uniqueDomId = `${controlId.replace(/[^a-zA-Z0-9]/g, '-')}-${compUuid}`;

                    const stateEl = entry.querySelector(`#state-${uniqueDomId}`);
                    const descriptionEl = entry.querySelector(`#desc-${uniqueDomId}`);
                    const nameEl = entry.querySelector(`#name-${uniqueDomId}`);
                    const dateEl = entry.querySelector(`#date-${uniqueDomId}`);

                    if (!stateEl) return;

                    const state = stateEl.value;
                    const description = descriptionEl.value;
                    const name = nameEl.value;
                    const date = dateEl.value;
                    
                    // Check if any meaningful data exists to save
                    if (state || description || name || date) {
                        let req = requirements.find(r => r['control-id'] === controlId);
                        if (!req) {
                            req = { "uuid": generateUUID(), "control-id": controlId, "by-components": [] };
                            requirements.push(req);
                        }
                        if (!req['by-components']) req['by-components'] = [];

                        let byCompEntry = req['by-components'].find(bc => bc['component-uuid'] === compUuid);
                        if (!byCompEntry) {
                            byCompEntry = {
                                "uuid": generateUUID(),
                                "component-uuid": compUuid,
                                "description": description,
                                "implementation-status": { "state": state || "partial" }, // Default to partial if description exists but state is empty
                                "props": []
                            };
                            req['by-components'].push(byCompEntry);
                        } else {
                            byCompEntry.description = description;
                            if(!byCompEntry['implementation-status']) byCompEntry['implementation-status'] = {};
                            byCompEntry['implementation-status'].state = state || "partial";
                            if(!byCompEntry.props) byCompEntry.props = [];
                        }

                        const setProp = (n, v) => {
                            let p = byCompEntry.props.find(x => x.name === n);
                            if(v) { p ? p.value = v : byCompEntry.props.push({ "name": n, "value": v }); }
                            else { byCompEntry.props = byCompEntry.props.filter(x => x.name !== n); }
                        };
                        setProp('implementing-user', name);
                        setProp('implementation-date', date);
                        
                        if (byCompEntry.props.length === 0) delete byCompEntry.props;

                    } else {
                        // Lösch-Logik, wenn alle Felder leer sind
                        let req = requirements.find(r => r['control-id'] === controlId);
                        if (req && req['by-components']) {
                            req['by-components'] = req['by-components'].filter(bc => bc['component-uuid'] !== compUuid);
                            // The cleanup of empty requirements happens after the loop.
                        }
                    }
                });

                // Cleanup: Remove requirements that no longer have any by-components entries
                requirements = requirements.filter(req => req['by-components'] && req['by-components'].length > 0);

                // Update the requirements array in the SSP object
                ssp['control-implementation']['implemented-requirements'] = requirements;

                const dataStr = JSON.stringify(sspData, null, 2);
                // Use UTF-8 Blob for saving
                const dataBlob = new Blob([dataStr], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url; a.download = sspFileName;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);

            } catch (error) {
                console.error(error);
                alert("Fehler beim Speichern: " + error.message);
            }
        }
    </script>
</body>
</html>
